# File generated by confd

# Rule ranges:
#   000 - 099 Rules that we statically manage
#   100 - 199 TCP confd generated rules
#   200 - 299 UDP confd generated rules
#   990 - 999 Bottom of the file rules

$mac_addr = $::networking['interfaces']['eth1']['mac']
$vpc_cidr = $::ec2_metadata['network']['interfaces']['macs'][$mac_addr]['vpc-ipv4-cidr-block']

class { 'firewall': }

resources { 'firewall':
    purge   => true,
}

# Default chains to accept
# All trafic destined for this host, filtered by security groups first
firewallchain { 'INPUT:filter:IPv4':
    ensure  => 'present',
    policy  => 'drop',
}

# All trafic out from this host, filtered by security groups first
firewallchain { 'OUTPUT:filter:IPv4':
    ensure  => 'present',
    policy  => 'accept',
}

# Forwarding traffic is dropped by default (rejected nicer lower)
firewallchain { 'FORWARD:filter:IPv4':
    ensure  => 'present',
    policy  => 'drop',
}

# Nat iptable for traffic leaving on our public interface
firewall { "000 snat for network":
  chain    => 'POSTROUTING',
  jump     => 'MASQUERADE',
  proto    => 'all',
  outiface => 'eth0',
  table    => 'nat',
}

# Allow all traffic thatis part of already known flows
firewall { '000 accept established flows':
  chain   => 'INPUT',
  proto   => 'all',
  state   => [ 'ESTABLISHED','RELATED' ],
  action  => 'accept',
}

# Allow all loopback in
firewall { '001 loopback in':
  chain     => 'INPUT',
  proto     => 'all',
  state     => [ 'NEW' ],
  iniface   => 'lo',
  action    => 'accept',
}

# Allow DHCP in
firewall { '002 dhcp in':
  chain     => 'INPUT',
  proto     => 'udp',
  dport     => [ 'bootpc','bootps' ],
  action    => 'accept',
}

# Allow all ICMP in
firewall { '003 ICMP in':
  chain     => 'INPUT',
  proto     => 'icmp',
  state     => [ 'NEW' ],
  action    => 'accept',
}

# Allow ssh IN internally
firewall { '004 SSH in':
  chain     => 'INPUT',
  proto     => 'tcp',
  dport     => 'ssh',
  state     => [ 'NEW' ],
#: For convenience, allow ssh from anywhere, rely on security groups to filter that out
#  iniface   => 'eth1',
  action    => 'accept',
}

# Allow Squid/tcp IN for all our VPC (either interface, because ELBs are silly)
firewall { '005 Squid/tcp in':
  chain     => 'INPUT',
  proto     => 'tcp',
  dport     => '3128',
  source    => $vpc_cidr,
  state     => [ 'NEW' ],
  action    => 'accept',
}

# Allow Consul/tcp IN internally
firewall { '006 Consul/tcp in':
  chain     => 'INPUT',
  proto     => 'tcp',
  dport     => '8300-8302',
  state     => [ 'NEW' ],
  iniface   => 'eth1',
  action    => 'accept',
}

# Allow Consul/udp IN internally
firewall { '007 Consul/udp in':
  chain     => 'INPUT',
  proto     => 'udp',
  dport     => '8300-8302',
  state     => [ 'NEW' ],
  iniface   => 'eth1',
  action    => 'accept',
}

# Allow conntrackd/udp
firewall { '007 conntrackd/udp in':
  chain     => 'INPUT',
  proto     => 'udp',
  dport     => '3780',
  state     => [ 'NEW' ],
  iniface   => 'eth1',
  action    => 'accept',
}

# Allow node monitoring IN internally
firewall { '008 node monitoring IN':
  chain     => 'INPUT',
  proto     => 'tcp',
  dport     => '9100-9110',
  state     => [ 'NEW' ],
  iniface   => 'eth1',
  action    => 'accept',
}

# Allow all traffic thatis part of already known flows
firewall { '002 accept established flows':
  chain   => 'FORWARD',
  proto   => 'all',
  state   => [ 'ESTABLISHED','RELATED' ],
  action  => 'accept',
}

# Allow all ICMP out
firewall { '004 ICMP':
  chain     => 'FORWARD',
  proto     => 'icmp',
  state     => [ 'NEW' ],
  outiface  => 'eth0',
  iniface   => 'eth1',
  action    => 'accept',
}

# Allow all NTP out
firewall { '005 NTP':
  chain     => 'FORWARD',
  proto     => 'udp',
  dport     => 'ntp',
  state     => [ 'NEW' ],
  outiface  => 'eth0',
  iniface   => 'eth1',
  action    => 'accept',
}

# Allow all out on port 636
firewall { '007 LDAP-636':
  chain     => 'FORWARD',
  proto     => 'tcp',
  dport     => '636',
  state     => [ 'NEW' ],
  outiface  => 'eth0',
  iniface   => 'eth1',
  action    => 'accept',
}

{{ if exists "/config/IptablesAllowTCP" }}{{ range jsonArray (getv "/config/IptablesAllowTCP") }}
firewall { '100 IptablesAllowTCP {{.}}':
  chain     => 'FORWARD',
  proto     => 'tcp',
  dport     => '{{.}}',
  state     => [ 'NEW' ],
  outiface  => 'eth0',
  iniface   => 'eth1',
  action    => 'accept',
}
{{end}} {{end}}

{{ if exists "/config/IptablesAllowUDP" }}{{ range jsonArray (getv "/config/IptablesAllowUDP") }}
firewall { '200 IptablesAllowUDP {{.}}':
  chain     => 'FORWARD',
  proto     => 'udp',
  dport     => '{{.}}',
  state     => [ 'NEW' ],
  outiface  => 'eth0',
  iniface   => 'eth1',
  action    => 'accept',
}
{{end}} {{end}}

# Finally

# Log INPUT traffic that will be dropped
firewall { '998 INPUT logging':
    chain      => 'INPUT',
    jump       => 'LOG',
    log_level  => '6',
    log_prefix => '[fwdeny-input] ',
    proto      => 'all',
}

# And drop it
firewall { "999 INPUT reject":
    chain   => 'INPUT',
    proto   => 'all',
    action  => 'reject',
}

# Log FORWARD traffic that will be dropped
firewall { '998 FORWARD logging':
    chain      => 'FORWARD',
    jump       => 'LOG',
    log_level  => '6',
    log_prefix => '[fwdeny-forward] ',
    proto      => 'all',
}

# And drop it
firewall { "999 deny forward":
    chain   => 'FORWARD',
    proto   => 'all',
    action  => 'reject',
}
